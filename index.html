#!/usr/bin/env bash
# shellcheck disable=SC1090
cat >/dev/null << '#sh.djeeno.com'
<link rel="icon" href="/favicon.ico" type="image/x-icon"><style>body{font-size:0;margin:0}pre{font-size:1rem;font-family:'Ricty Diminished',Osaka,Menlo,Monaco,Consolas,'Courier New','Andale Mono','Ubuntu Mono',monospace}</style><pre><code>##
#sh.djeeno.com
##

cat << DOCUMENT | stderrPipeNotice
+--!!注意!!----------------------------------------------------------------------------+
| この index.html をシェルスクリプトとして実行しないでください。                       |
| この index.html はシェルスクリプトとして実行されることを想定して作成されていません。 |
+--------------------------------------------------------------------------------------+

個人用コマンドチートシート。

(C) 2018 djeeno
DOCUMENT
exit 0

# ====================================================================================================
#   ここから
# ====================================================================================================

# ==================================================
# 共通
# ==================================================

# stderrPipe : いい感じログを出す。
stderrPipeDebug ()  { awk '{print "\033[00m'"$(TZ=Asia/Tokyo date +"%Y-%m-%dT%H:%M:%S+09:00")"' [  debug] "$0"\033[0m"}' /dev/stdin 1>&2; } && export -f stderrPipeDebug
stderrPipeNotice () { awk '{print "\033[01m'"$(TZ=Asia/Tokyo date +"%Y-%m-%dT%H:%M:%S+09:00")"' [ notice] "$0"\033[0m"}' /dev/stdin 1>&2; } && export -f stderrPipeNotice
stderrPipeError ()  { awk '{print "\033[31m'"$(TZ=Asia/Tokyo date +"%Y-%m-%dT%H:%M:%S+09:00")"' [  error] "$0"\033[0m"}' /dev/stdin 1>&2; } && export -f stderrPipeError
stderrPipeOK ()     { awk '{print "\033[32m'"$(TZ=Asia/Tokyo date +"%Y-%m-%dT%H:%M:%S+09:00")"' [     ok] "$0"\033[0m"}' /dev/stdin 1>&2; } && export -f stderrPipeOK
stderrPipeWarn ()   { awk '{print "\033[33m'"$(TZ=Asia/Tokyo date +"%Y-%m-%dT%H:%M:%S+09:00")"' [warning] "$0"\033[0m"}' /dev/stdin 1>&2; } && export -f stderrPipeWarn
stderrPipeInfo ()   { awk '{print "\033[34m'"$(TZ=Asia/Tokyo date +"%Y-%m-%dT%H:%M:%S+09:00")"' [   info] "$0"\033[0m"}' /dev/stdin 1>&2; } && export -f stderrPipeInfo

# wget : 1 つの HTML ファイルとして保存する。
wget --mirror --page-requisites --html-extension --convert-links https://github.com/

# ssh-keygen : 秘密鍵を作成する。
ssh-keygen -t ed25519 -f ed25519_256.pem -C "https://sh.djeeno.com/keys" -N ""
ssh-keygen -t ecdsa -b 521 -f ecdsa_521.pem -C "https://sh.djeeno.com/keys" -N ""
ssh-keygen -t rsa -b 4096 -f rsa_4096.pem -C "https://sh.djeeno.com/keys" -N ""
# ssh-keygen : 公開鍵のフィンガープリントを表示する。
ssh-keygen -E md5 -l -f _path_to_public_key_

# rsync : 網羅的なコマンド例。
rsync -az -e 'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no' --rsync-path='ionice -c 3 nice -n 19 rsync' --exclude '.git' --exclude '.gitmodules' "${SSHUSER:?}@${SSHHOST:?}:~/" "/tmp/${SSHUSER:?}_${SSHHOST:?}/"

# difff : diff と sed だけで作られた色付き diff 。
difff() { (R=$(printf '\033[31m');G=$(printf '\033[32m');B=$(printf '\033[36m');W=$(printf '\033[1m');N=$(printf '\033[0m');diff -u "$@"|sed "s/^\(@@..*@@\)$/$B\1$N/g;s/^\(+.*\)$/$G\1$N/g;s/^\(-.*\)$/$R\1$N/g;s/^[^+-]*\(+++ [^ ].*\)/$W\1$N/g;s/^[^+-]*\(--- [^ ].*\)/$W\1$N/g;")}

# openssl : 証明書期限チェック。
openssl s_client -connect google.com:443 < /dev/null 2> /dev/null | openssl x509 -noout -dates
# openssl : 証明書チェーンチェック。
openssl s_client -connect google.com:443 < /dev/null 2> /dev/null | grep -E 'Certificate chain|[is]:/'

# find : 見つけたファイルの行数を出力する。 `+` 引数としてまとめて渡して実行。 `;` 個別に実行。
find . -name "*.html" -exec wc -l {} \+
find . -name "*.html" -exec wc -l {} \;

_readline_history() {
  if command -v brew >/dev/null; then
    brew install peco
  elif command -v apt-get >/dev/null; then
    apt-get update && apt-get install -y peco
  else
    echo "error: requires peco"
  fi
  READLINE_LINE=$(HISTTIMEFORMAT='' history | awk "{a[i++]=\$0}END{for(j=i-1;j>=0;j--)print a[j]}" | sed 's/^[[:space:]]*[0-9][0-9]*[[:space:]][[:space:]]*//' | peco --layout bottom-up)
  READLINE_POINT=${#READLINE_LINE}
} && bind -x '"\C-r":_readline_history'

# tac : ファイルの内容や標準入力の内容を逆順に出力する。 cat の逆。
tac() {
  awk_script="{a[i++]=\$0}END{for(j=i-1;j>=0;j--)print a[j]}"
  if [ $# -ge 1 ]; then
    cat "$@" | awk "${awk_script}"
  else
    awk "${awk_script}" /dev/stdin
  fi
}

# YAML と JSON を相互変換する。
ruby -ryaml -rjson -e 'puts YAML.dump(JSON.load(STDIN.read))'
ruby -ryaml -rjson -e 'puts JSON.dump(YAML.load(STDIN.read))'
ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(STDIN.read))'

# gcloud : Google Cloud SDK をインストールする。
bash -c "$(curl -fLRsS https://sdk.cloud.google.com/)" && command -v gcloud



# ==================================================
# Linux
# ==================================================

# du : ルートディレクトリより 1 階層掘って使用量を出力する。
du -h -d 1 --exclude=/proc /

# ps.sh : ps コマンドの代わり。
ps_sh() { _piddirs=$(find /proc -maxdepth 1 -type d -name '[0-9]*'); printf 'UID\tPID\tPPID\tCMD\n'; echo "$_piddirs" | sed s@/proc/@@ | while read -r PID; do if [ -d "/proc/$PID" ]; then printf '%s\t%d\t%d\t%s\n' "$(stat -c '%U' "/proc/$PID")" "$PID" "$(cut -d' ' -f4 "/proc/$PID/stat")" "$(cat -e "/proc/$PID/cmdline" | sed 's/\^@$//; s/\^@/ /g')"; fi; done; } && ps_sh

# alias : Linux 用よく使う alias 詰め合わせ。
alias rm='rm -i'; alias cp='cp -i'; alias mv='mv -i'; alias ls='ls --color=auto'; alias ll='ls -alF';

# CoreOS で tc コマンドを使う。
# ref. tc コマンドでネットワーク遅延やパケットロスを疑似的に発生させるメモ - ようへいの日々精進XP https://inokara.hateblo.jp/entry/2016/02/14/191853
toolbox
apt-get update && apt-get install -y iproute2
tc qdisc show   dev eth0
tc qdisc add    dev eth0 root netem delay 100ms
tc qdisc change dev eth0 root netem delay 200ms
tc qdisc del    dev eth0 root
tc qdisc add    dev eth0 root netem loss 5%
tc qdisc change dev eth0 root netem loss 10%
tc qdisc del    dev eth0 root



# ==================================================
# Mac
# ==================================================

# brew : Homebrew をインストールする。 ref. https://brew.sh/
bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)" && command -v brew



# ==================================================
# git Git
# ==================================================

# git : リポジトリのルートディレクトリを出力する。
git rev-parse --show-toplevel

# git : ブランチ名を出力する。
git rev-parse --abbrev-ref HEAD

# git : git-completion git コマンドの保管 ＆ git-prompt プロンプトに git の status などを表示
test -f ~/.git-completion.bash || bash -cx "curl -LR https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash"; test -f ~/.git-completion.bash && source "$_"
test -f ~/.git-prompt.sh || bash -cx "curl -LR https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -o ~/.git-prompt.sh"; test -f ~/.git-prompt.sh && source "$_"
export GIT_PS1_SHOWDIRTYSTATE=1 GIT_PS1_SHOWUPSTREAM=1 GIT_PS1_SHOWUNTRACKEDFILES=1 GIT_PS1_SHOWSTASHSTATE=1; if [ "${BASH_VERSINFO[0]}" -ge 4 ]; then export PS1="${PS1//"\\\$"/\\\$\\\[\\\e[1;31m\\\]\$(__git_ps1)\\\[\\\e[00m\\\]}"; else export PS1="${PS1//"\\\$"/\$\[\e[1;31m\]\$(__git_ps1)\[\e[00m\]}"; fi

# git : 最新版をソースからインストールする。 ref. https://www.kernel.org/pub/software/scm/git/
# shellcheck disable=SC2016
install_git() { $(command -v sudo) bash -cx 'apt-get update && apt-get install -y lib{curl4-gnutls,expat1,ssl,z}-dev gcc gettext make less tar wget && cd /usr/local/src && URL=https://www.kernel.org/pub/software/scm/git/ && FILE=$(wget -qO- $URL | grep -o -E git-[0-9\\.]+.tar.gz | sort -uV | tail -n 1) && wget -cSv $URL$FILE && tar vxzf $FILE && cd $(basename -s .tar.gz $FILE) && make prefix=/usr/local all && make prefix=/usr/local install && cd .. && rm -rf $FILE $(basename -s .tar.gz $FILE) && /usr/local/bin/git --version'; } && install_git
# shellcheck disable=SC2016
install_git() { $(command -v sudo) bash -cx 'yum makecache && yum install -y {curl,expat,gettext,openssl,zlib}-devel gcc make less tar perl-ExtUtils-MakeMaker wget && cd /usr/local/src && URL=https://www.kernel.org/pub/software/scm/git/ && FILE=$(wget -qO- $URL | grep -o -E git-[0-9\\.]+.tar.gz | sort -uV | tail -n 1) && wget -cSv $URL$FILE && tar vxzf $FILE && cd $(basename -s .tar.gz $FILE) && make prefix=/usr/local all && make prefix=/usr/local install && cd .. && rm -rf $FILE $(basename -s .tar.gz $FILE) && /usr/local/bin/git --version'; } && install_git



# ==================================================
# docker Docker
# ==================================================

# docker : djeeno/ubuntu:18.04 の docker コンテナを起動する。
docker run -it --rm djeeno/ubuntu:18.04 bash

# docker : 今いる Git リポジトリをボリュームとしてマウントし docker コンテナを起動する。
docker run -it --rm -v "$HOME/.ssh:/root/.ssh:ro" -v "$HOME/.gitconfig:/root/.gitconfig" -v "$(git rev-parse --show-toplevel):$(git rev-parse --show-toplevel)" djeeno/workspace:latest bash -c "cd $(git rev-parse --show-toplevel) && bash -l"

# docker : docker --cap-add=SYS_ADMIN と /sys/fs/cgroup の例。極めて強い権限のため取り扱い注意。
docker run -it --rm --cap-add=SYS_ADMIN -v /sys/fs/cgroup:/sys/fs/cgroup:ro debian:10.2 bash

# docker : よく使いそうな docker image たち
docker run -it --rm debian:10.2     bash
docker run -it --rm debian:9.11     bash
docker run -it --rm debian:8.11     bash
docker run -it --rm ubuntu:18.04    bash
docker run -it --rm ubuntu:16.04    bash
docker run -it --rm ubuntu:14.04    bash
docker run -it --rm centos:8.1.1911 bash
docker run -it --rm centos:7.7.1908 bash
docker run -it --rm centos:6.10     bash

# docker : MySQL Server のコンテナを起動する。
docker network create common
docker run -di --rm --network common --name mysql_8_0 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:8.0
docker run -di --rm --network common --name mysql_5_7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:5.7
docker run -di --rm --network common --name mysql_5_6 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:5.6
docker run -di --rm --network common --name mysql_8_0 -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_ROOT_PASSWORD="" mysql:8.0
docker run -di --rm --network common --name mysql_5_7 -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_ROOT_PASSWORD="" mysql:5.7
# docker : MySQL Server への接続コマンドをコンテナ上で実行する。
docker run -it --rm --network common mysql:8.0 sh -c "mysql -h mysql_8_0 -P 3306 -u root --password=password"
docker run -it --rm --network common mysql:5.7 sh -c "mysql -h mysql_5_7 -P 3306 -u root --password=password"
docker run -it --rm --network common mysql:5.6 sh -c "mysql -h mysql_5_6 -P 3306 -u root --password=password"
# docker : ローカルから docker 上の mysql への接続コマンド。
mysql -h 127.0.0.1 -P 3306 -u root --password=password

# docker : PostgreSQL Server のコンテナを起動する。
docker run -di --rm --network common --name postgres_9_6 -p 5432:5432 -e POSTGRES_PASSWORD=password postgres:9.6
# docker : PostgreSQL Server への接続コマンドをコンテナ上で実行する。
docker run -it --rm --network common postgres:9.6 sh -c "PGPASSWORD=password psql -h postgres_9_6 -U postgres"

# docker : Redis Server のコンテナを起動する。
docker run -di --rm --network common --name redis_5_0 -p 6379:6379 redis:5.0
docker run -di --rm --network common --name redis_4_0 -p 6379:6379 redis:4.0
docker run -di --rm --network common --name redis_3_2 -p 6379:6379 redis:3.2
docker run -di --rm --network common --name redis_2_8 -p 6379:6379 redis:2.8
# docker : Redis Server への接続コマンドをコンテナ上で実行する。
docker run -it --rm --network common redis:5.0 sh -c "redis-cli -h redis_5_0 -p 6379"
docker run -it --rm --network common redis:4.0 sh -c "redis-cli -h redis_4_0 -p 6379"
docker run -it --rm --network common redis:3.2 sh -c "redis-cli -h redis_3_2 -p 6379"
docker run -it --rm --network common redis:2.8 sh -c "redis-cli -h redis_2_8 -p 6379"

# docker : コンテナから CLI を実行する（ローカル環境を汚さないため）。
alias     mysql-docker='docker run -it --rm mysql:8.0 mysql'
alias redis-cli-docker='docker run -it --rm redis:5.0 redis-cli'
alias       aws-docker='docker run -it --rm -e AWS_PROFILE="${AWS_PROFILE}" -e AWS_REGION="${AWS_PROFILE}" -v ~/.aws:/root/.aws djeeno/awscli aws'

# docker : ビルド時に作成された不要な中間イメージを掃除する。
docker image ls --filter "dangling=true" -aq | xargs docker image rm

# docker : 全部 kill して rm する。
{ docker ps -aq | xargs docker kill; docker ps -aq | xargs docker rm; }

# docker : 掃除する。
{ docker container prune -f; docker volume prune -f; docker image prune -f; }
docker system prune

# docker : docker を root ユーザー以外でも実行できるように。
sudo usermod -aG docker "$USER"

# docker : Docker for Windows を WSL1 から利用できるようにするための設定。
command -v docker.exe 1>/dev/null && export DOCKER_HOST=tcp://localhost:2375

# docker : Docker for Mac の LinuxKit の tty に接続する。
screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty

# docker-compose : 最新の docker-compose をインストールする。
DOCKER_COMPOSE_URL="$(echo "https://github.com$(curl -LRsS https://github.com/docker/compose/releases | grep -Eo "/docker/compose/releases/download/[0-9\.]+/docker-compose-$(uname -s)-$(uname -m)" | head -n 1)" | tee /dev/stderr)"
sudo curl -LRsS "${DOCKER_COMPOSE_URL:?}" -o /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose

# docker-compose : `ERROR: readlink /var/lib/docker/overlay2: invalid argument` が出た時に実行する。
docker-compose down --rmi local
docker-compose down --rmi all

# api コンテナから db コンテナに MySQL 接続する。
docker-compose exec api bash -c 'mysql -h db -P 3306 -u root --password=password'



# ==================================================
# Kubernetes
# ==================================================

# kubectl : kubectl is a function that wraps kubectl commands and checks the Kubernetes context at run-time.
kubectl() {
  # if has 1 argument || has -h --help --dry-run option || Sub-commands that are not dangerous if executed without confirmation; then
  if [ $# -le 1 ] || { echo " $* " | grep -Eq -- ' -h | --help | --dry-run '; } \
    || { echo " $* " | grep -Eq ' api-resources | api-version | cluster-info | completion | config | describe | diff | explain | get | logs | top | version | wait '; }; then
    command kubectl "$@"
    return $?
  fi
  printf "\e[01;33m%s\n%s\e[0m" "# CurrentContext: " "#   "
  command kubectl config current-context
  printf "\e[01;33m%s\e[0m" "# Press Enter key to continue... "
  read -r
  command kubectl "$@"
}



# ==================================================
# GCP
# ==================================================

# gcloud : 変な operations が起こっていないか確認する。
gcloud compute operations list --sort-by=TIMESTAMP



# ==================================================
# vim
# ==================================================

# vim : ${hoge} を ${hoge:?} に変換する。
# vim :%s/\(\${[^:{}]*[^\?"]\)}/\1:?}/gc



# ====================================================================================================
#   ここまで
# ====================================================================================================

# (C) 2018 djeeno </code></pre>
