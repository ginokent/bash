#!/usr/bin/env bash
# shellcheck disable=SC1090
cat >/dev/null <<'# djeeno.github.io'
<link rel="icon" href="/favicon.ico" type="image/x-icon"><style>body{font-size:0;margin:0}code{font-size:1rem;font-family:'Ricty Diminished',Osaka,Menlo,Monaco,Consolas,'Courier New','Andale Mono','Ubuntu Mono',monospace}</style><pre><code>##
# djeeno.github.io
##

cat << DOCUMENT | awk '{print "\033[01m[ notice]: "$0"\033[0m"}' 1>&2

!!注意!!
  このファイルを実行しないでください。
  このファイルは実行されることを想定して作成されていません。

よく使うかもしれないコマンド群の個人用チートシートです。

以下のように curl コマンドなどの CLI から参照されることを想定しています。

$ curl https://djeeno.github.io/

(C) 2018 djeeno

DOCUMENT

# 正常終了
exit 0

# ====================================================================================================
#   ここから
# ====================================================================================================

# ==================================================
# 共通
# ==================================================

# cdiff : diff と sed だけで作られた色付き diff
cdiff() { (R=$(printf '\e[31m');G=$(printf '\e[32m');B=$(printf '\e[36m');W=$(printf '\e[1m');N=$(printf '\e[0m');diff -u "$@"|sed "s/^\(@@..*@@\)$/$B\1$N/g;s/^\(+.*\)$/$G\1$N/g;s/^\(-.*\)$/$R\1$N/g;s/^[^+-]*\(+++ [^ ].*\)/$W\1$N/g;s/^[^+-]*\(--- [^ ].*\)/$W\1$N/g;")}



# ==================================================
# git Git
# ==================================================

# git : リポジトリのルートディレクトリを出力する。
git rev-parse --show-toplevel

# git : git-completion & git-prompt プロンプトに各種情報を表示
test -f ~/.git-completion.bash || curl -LR https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash; test -f ~/.git-completion.bash && source "$_"
test -f ~/.git-prompt.sh || curl -LR https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -o ~/.git-prompt.sh; test -f ~/.git-prompt.sh && source "$_"
export GIT_PS1_SHOWDIRTYSTATE=1 GIT_PS1_SHOWUPSTREAM=1 GIT_PS1_SHOWUNTRACKEDFILES=1 GIT_PS1_SHOWSTASHSTATE=1
if [ "${BASH_VERSINFO[0]}" -ge 4 ]; then export PS1="${PS1//"\\\$"/\\\$\\\[\\\e[1;31m\\\]\$(__git_ps1)\\\[\\\e[00m\\\]}"; else export PS1="${PS1//"\\\$"/\$\[\e[1;31m\]\$(__git_ps1)\[\e[00m\]}"; fi



# ==================================================
# docker Docker
# ==================================================

# docker : djeeno/ubuntu:18.04 の docker コンテナを起動する。
docker run -it --rm djeeno/ubuntu:18.04 bash

# docker : 今いる Git リポジトリをボリュームとしてマウントし docker コンテナを起動する。
docker run -it --rm -v "$HOME/.ssh:/root/.ssh:ro" -v "$(git rev-parse --show-toplevel):/workspace" djeeno/ubuntu:18.04 bash

# docker : docker --cap-add=SYS_ADMIN と /sys/fs/cgroup の例。極めて強い権限のため取り扱い注意。
docker run -it --rm --cap-add=SYS_ADMIN -v /sys/fs/cgroup:/sys/fs/cgroup:ro debian:10.2 bash

# docker : よく使いそうな docker image たち
docker run -it --rm debian:10.2     bash
docker run -it --rm debian:9.11     bash
docker run -it --rm debian:8.11     bash
docker run -it --rm ubuntu:18.04    bash
docker run -it --rm ubuntu:16.04    bash
docker run -it --rm ubuntu:14.04    bash
docker run -it --rm centos:8.1.1911 bash
docker run -it --rm centos:7.7.1908 bash
docker run -it --rm centos:6.10     bash

# docker : MySQL Server のコンテナを起動する。
docker network create common
docker run -di --rm --network common --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:8.0
docker run -di --rm --network common --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:5.7
docker run -di --rm --network common --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password mysql:5.6
docker run -di --rm --network common --name mysql -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_ROOT_PASSWORD="" mysql:8.0
docker run -di --rm --network common --name mysql -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_ROOT_PASSWORD="" mysql:5.7
# docker : MySQL Server への接続コマンドをコンテナ上で実行する。
docker run -it --rm --network common mysql:8.0 sh -c "mysql -h mysql -P 3306 -u root --password=password"
docker run -it --rm --network common mysql:5.7 sh -c "mysql -h mysql -P 3306 -u root --password=password"
docker run -it --rm --network common mysql:5.6 sh -c "mysql -h mysql -P 3306 -u root --password=password"
# docker : ローカルから docker 上の mysql への接続コマンド。
mysql -h 127.0.0.1 -P 3306 -u root --password=password

# docker : PostgreSQL Server のコンテナを起動する。
docker run -di --rm --network common --name postgres -p 5432:5432 -e POSTGRES_PASSWORD=password postgres:9.6.17
# docker : PostgreSQL Server への接続コマンドをコンテナ上で実行する。
docker run -it --rm --network common postgres:9.6.17 sh -c "PGPASSWORD=password psql -h postgres -U postgres"

# docker : Redis Server のコンテナを起動する。
docker run -di --rm --network common --name redis -p 6379:6379 redis:2.8
# docker : Redis Server への接続コマンドをコンテナ上で実行する。
docker run -it --rm --network common redis:2.8 sh -c "redis-cli -h redis"

# docker : ビルド時に作成された不要な中間イメージを掃除する。
docker image ls --filter "dangling=true" -aq | xargs docker image rm

# docker : 全部 kill して rm する。
{ docker ps -aq | xargs docker kill; docker ps -aq | xargs docker rm; }

# docker : 掃除する。
{ docker container prune -f; docker volume prune -f; docker image prune -f; }
docker system prune

# docker : docker を root ユーザー以外でも実行できるように。
sudo usermod -aG docker "$USER"

# docker : Docker for Windows を WSL1 から利用できるようにするための設定。
command -v docker.exe 1>/dev/null && export DOCKER_HOST=tcp://localhost:2375

# docker : Docker for Mac の LinuxKit の tty に接続する。
screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty

# docker-compose : 最新の docker-compose をインストールする。
DOCKER_COMPOSE_URL="$(echo "https://github.com$(curl -LRsS https://github.com/docker/compose/releases | grep -Eo "/docker/compose/releases/download/[0-9\.]+/docker-compose-$(uname -s)-$(uname -m)" | head -n 1)" | tee /dev/stderr)"
sudo curl -LRsS "${DOCKER_COMPOSE_URL:?}" -o /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose

# docker-compose : `ERROR: readlink /var/lib/docker/overlay2: invalid argument` が出た時に実行する。
docker-compose down --rmi local
docker-compose down --rmi all



# ==================================================
# Kubernetes
# ==================================================

# kubectl : kubectl is a function that wraps kubectl commands and checks the Kubernetes context at run-time.
kubectl() {
  # if has 1 argument || has -h --help --dry-run option || Sub-commands that are not dangerous if executed without confirmation; then
  if [ $# -le 1 ] || { echo " $* " | grep -Eq -- ' -h | --help | --dry-run '; } \
    || { echo " $* " | grep -Eq ' api-resources | api-version | cluster-info | completion | config | describe | diff | explain | get | logs | top | version | wait '; }; then
    command kubectl "$@"
    return $?
  fi
  printf "\e[01;33m%s\n%s\e[0m" "# CurrentContext: " "#   "
  command kubectl config current-context
  printf "\e[01;33m%s\e[0m" "# Press Enter key to continue... "
  read -r
  command kubectl "$@"
}

# ==================================================
# Linux
# ==================================================

# du : ルートディレクトリより 1 階層掘って使用量を出力する
du -h -d 1 --exclude=/proc /



# ====================================================================================================
#   ここまで
# ====================================================================================================

# (C) 2018 djeeno </code></pre>
